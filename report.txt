Contents
Table of Contents

I

1 Introduction

1

2 Analysis
2.1 Concurrent Programming . .
2.2 Ruby . . . . . . . . . . . . . .
2.2.1 Concurrency in Ruby
2.2.2 Ruby Implementations
2.3 HTTP & TCP . . . . . . . .
2.4 Webservers . . . . . . . . . .
2.4.1 Apache HTTP Server
2.4.2 Rack . . . . . . . . . .
2.4.3 Thin . . . . . . . . . .
2.5 Literature Review . . . . . .
2.6 Requirements Speciﬁcation .
2.7 Development Method . . . . .

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.

3
3
4
4
4
5
5
5
6
6
6
6
6

3 Design

7

4 Implementation

9

5 Testing & Evaluation

11

6 Conclusion

13

7 Future Works

15

Bibliography

17

Appendices

19

A Acceptance Tests

21

Todo

22

I

Chapter 1

Introduction

1

Chapter 2

Analysis
Meta: Introduction to the topics covered and why they are included.

5

10

15

20

25

30

2.1

Concurrent Programming

Concurrency refers to code which is executed simultaneusly on one or more
processors or cores in a single processor. Concurrent Programming refers to
programming language constructs which enables code to be executed concurrently. Concurrent code executed on a single-core processor will look like it’s
executed at the same time, but in reality the processor executes increments
of each piece of code by switching back and forth between them. The way a
processor switches between concurrent tasks is referred to as context-switching,
and can easily bog down a system as the context (program state and variables)
needs to be loaded for every context-switch. Concurrent code executed on a
multi-core processor has the potential to execute code in parallel, e.g. at the
same instance in time.
In most programming languages code is executed one statement at a time
in a sequential maner. Most programming languages does however include
constructs to allow for concurrent programming. One of the most commen
constructs is threads. A thread is an abstraction for a piece of code which is
executed as a subroutine of the running program. This allows for executing several threads concurrently or in parallel on multiple processors. In Section 2.2,
the constructs available in Ruby are covered in more detail.
Concurrency introduces several complications which must be taken into account, mainly; race conditions and deadlocks. A race condition occurs when
two or more pieces of code tries to manipulate the same variable, and the outcome of the program changes depending on the order of the manipulations. An
example would be if two threads, A and B, stored a counter in a global variable.
Imagine thread A reads the value of the counter and then gets descheduled and
thread B changes the counter and saves it. Then when thread A gets resumed
it would have an incorrect counter value, and changing the counter based on
this would render thrad B’s previous change. Race conditions can be ﬁxed
3

4

CHAPTER 2. ANALYSIS

by synchronizing access to shared resources such as variables. A commen way
too synchronize access to shared resources is to add a mutual exclusion lock
(mutex) around the code which accesses the shared resource. A mutex could
ensure that only one thread uses the shared counter varible at a time.

5

10

15

2.2

Ruby

Meta: Ruby in general. Concurrent programming in ruby. Describe diﬀerent implementations.
Ruby is an dynamic, reﬂective object-oriented general-purpose programming
language. It is dynamic in the sense that it is interpreted at runtime, and
reﬂective in the sense that it can modify and inspect program behavior during
runtime. Ruby has a dynamic type system where the type of the object is
determined by what the object can do in terms of which methods are available
for the object. This type system is referred to as duck typing, i.e. if it walks
like a duck and talks like a duck, then the interpreter will treat it like a duck.
The latest version of Ruby, version 1.9, holds several improvements over
the older but still maintained version 1.8. Besides small syntactic changes and
including a new VM, Ruby 1.9 introduced the concept of ﬁbers. The following
section covers the options available for concurrent programming in Ruby.

2.2.1
20

Concurrency in Ruby

Ruby comes with several constructs for concurrent programming; ﬁbers,
threads and processes. The following describes the advantages and possible
disadvantages of each of these concepts.

Fibers
Threads
25

Processes

2.2.2

30

35

Ruby Implementations

Ruby code is run in a virtual machine (VM) of which there exists several
implementations. The oﬃcial Ruby VM, for Ruby 1.9, is called YARV (Yet
Another Ruby VM). As there is no speciﬁcation for Ruby, YARV serves as the
reference implementation for the Ruby language. There is however a project
called RubySpec which aims to write an executable speciﬁcation in the form
of unit-tests which, is executed against the Ruby VM implementation to verify
that it executes Ruby correctly. The following describes three widely used
Ruby implementations, namely YARV, Rubinius and JRuby, and how they
facilitate concurrent programming.

2.3. HTTP & TCP

5

Yet Another Ruby VM
YARV is developed an maintained as the oﬃcial Ruby implementation and
replaced the old VM MRI (Matz1 Ruby Interpreter) as of Ruby version 1.9.

Rubinius
5

JRuby
JRuby is

2.3
2.4

10

15

20

HTTP & TCP
Webservers

Cover several webservers, each with their unique way of handling concurrent
requests.
The goal of a webserver is listen on a port for incoming requests, handle
them by either returning the contents of a ﬁle, run a program and return it’s
output, or, if an error occurred, return an error message. Since the Internet was
made public over 20 years ago there have been countless webservers created,
most of which focus on handling websites written in a speciﬁc programming
language or framework. Multi-core processors have long been available in server
environments and hence, many webservers employ techniques to raise their
performance by handling http requests in parallel.
This section looks at some of the current webservers and how they went
about solving the problem of handling multiple http request in parallel.

2.4.1

25

30

Apache HTTP Server

Apache HTTP Server, or simply Apache, was initially released in 1995 and
is the most used web server today surpassing 100 million websites in 2009 [3].
Apache supports many diﬀerent functionalities and programming languages
as it can be extended by modules. Popular modules provide authentication,
encryption, compression and multi-processing. To handle concurrent requests
Apaches main process (the parent) forks child processes. When using the multiprocessing module, each each child process contains a ﬁxed number of server
threads and one listener thread which divides incoming request amongst the
server threads. This increases the throughput of Apache signiﬁcantly when
dealing with a high volume of concurrent requests [2].
1 Yukihiro

Matsumoto, a.k.a. Matz is the creator of the Ruby programming language

6

CHAPTER 2. ANALYSIS

2.4.2

5

10

15

Rack

Rack is not an actual webserver, but an interface between webservers supporting Ruby and Ruby frameworks. It is covered here as the Ruby webservers
covered next both implement it. Rack decouples the link between the webserver
and web-application (written in one of the many Ruby frameworks) and hereby
makes it possible to change webserver without having to make any changes to
the web application. This is achieved by wrapping requests and responses in a
Ruby object. By implementing the Rack interface, a webserver would immediately become compatible with more than 15 Ruby frameworks [1].

2.4.3

Thin

Thin is a webserver written in Ruby which include a http parser written in
C, implements the Rack interface and uses EventMachine to handle requests
in a concurrent non-blocking manner. EventMachine is a library which enables
event-driven (non-blocking) I/O by utilizing the reactor design pattern. The
reactor pattern works by having a dispatcher (reactor) passing on work to
various handlers, which then in turn ﬁre an event when ﬁnished. This enables
Thin to focus on other requests instead of waiting on blocking actions such as
waiting for a ﬁle to be written to disk or fetching data from a remote API [4].

2.5
20

Literature Review

2.6

Requirements Speciﬁcation

In order to have a clear goal of what the software produced in this project
should do, a set of requirements are essential. The following lists the requirements for the software developed in this project.
• Handle a high volume of concurrent requests.
25

• Implement the Rack interface.
• Logging of requests and responses.
• Handle multiple request in non-blocking parallel.

30

As this project was developed using BDD, the requirements speciﬁcation
was translated into a set of acceptance tests to get concrete feedback on completed requirements. The acceptance tests are included as Appendix A.

2.7

Development Method

Chapter 3

Design
Link analysis to designi (red thread). Cover relevant design decisions and
patterns.

7

Chapter 4

Implementation

9

Chapter 5

Testing & Evaluation

11

Chapter 6

Conclusion

13

Chapter 7

Future Works

15

Bibliography
[1] Christian Neukirchen. The Rack Interface Speciﬁcation, 2010.
[2] Apache Foundation. Apache MPM worker, 2011.
[3] Netcraft. February 2009 Web Server Survey, 2009.
5

[4] Douglas C Schmidt. Reactor - An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events. Structure, pages
1–11, 1995.
[5] ThoughtWorks. Concurrency patterns in Ruby.

17

Appendices

19

Appendix A

Acceptance Tests
FiXme Fatal: Include acceptance/cucumber tests

21

22

APPENDIX A. ACCEPTANCE TESTS

List of Corrections
Fatal: Include acceptance/cucumber tests . . . . . . . . . . . . . . . . .

21

